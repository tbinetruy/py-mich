* Goal of the project

We'd like to compile Python code to Tezos' Micelson bytecode using Python's  ~ast~ module. So fare, what has been implemented is:

- a virtual machine with a Michelson-like bytecode. Ideally it would need to be identical rather than inspired, I will be working on this in the following weeks [1]. The VM is in ~vm.py~.
- a compiler backend from a Python ast to the Michelson implemented in the VM to speed up development and allow easy testing. The compiler is in ~compiler.py~.

[1] https://tezos.gitlab.io/whitedoc/michelson.html

* Usage

** Deploy on sandbox

Compile contract:

#+begin_src python
from compiler import Compiler
import json

source = """
@dataclass
class Storage:
    admin: address
    manifest_url: str
    manifest_hash: str
    open: str
    close: str
    artifacts_url: str
    artifacts_hash: str

@dataclass
class OpenArg:
    open: str
    manifest_url: str
    manifest_hash: str

@dataclass
class ArtifactsArg:
    artifacts_url: str
    artifacts_hash: str

class Contract:
    def deploy():
        return Storage("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb", '', '', '', '', '', '')

    def open(params: OpenArg) -> Storage:
        if self.sender != self.storage.admin:
            raise "Only owner can call open"

        self.storage.open = params.open
        self.storage.manifest_url = params.manifest_url
        self.storage.manifest_hash = params.manifest_hash

        return self.storage

    def close(params: str) -> Storage:
        if self.sender != self.storage.admin:
            raise "Only owner can call close"

        self.storage.close = params

        return self.storage

    def artifacts(params: ArtifactsArg) -> Storage:
        if self.sender != self.storage.admin:
            raise "Only owner can call artifacts"

        self.storage.artifacts_url = params.artifacts_url
        self.storage.artifacts_hash = params.artifacts_hash

        return self.storage
"""
contract = Compiler(source).compile().contract
micheline = CompilerBackend().compile_contract(contract)

with open("my_contract.json", "w+") as f:
    f.write(json.dumps(micheline))
#+end_src

Run contract on tezos sandbox using pytezos:

#+begin_src python
from pytezos import pytezos

key = pytezos.key.from_encoded_key("edsk3QoqBuvdamxouPhin7swCvkQNgq4jP5KZPbwWNnwdZpSpJiEbq")
sandbox_url = "http://tz:20000"
client = pytezos.using(key=key, shell=sandbox_url)

from pytezos import Contract

with open("my_contract.json") as f:
    source = f.read()

import json
from pytezos import ContractInterface
micheline = json.loads(source)
ci = ContractInterface.from_micheline(micheline)

init_storage = {'prim': 'Pair', 'args': [{'prim': 'Pair', 'args': [{'prim': 'Pair', 'args': [{'string': 'tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb'}, {'string': ''}]}, {'string': ''}, {'string': ''}]}, {'prim': 'Pair', 'args': [{'string': ''}, {'string': ''}]}, {'string': ''}]}

operation = client.origination(dict(code=micheline, storage=init_storage)).autofill().sign().inject()
result = client.shell.blocks[-200:].find_operation(operation['hash'])
contract_id = result['contents'][0]['metadata']['operation_result']['originated_contracts'][0]
contract = client.contract(contract_id)
#+end_src

We can now interact with the contract, let's list its entrypoints:

#+begin_src python
contract
#+end_src

#+begin_src
[...]

Entrypoints
.artifacts()
.close()
.open()
.default()

[...]
#+end_src

We can inspect the storage type:

#+begin_src python
contract.storage
#+end_src

#+begin_src python
[...]

Typedef
$storage:
  {
    "admin": address,
    "manifest_url": string,
    "manifest_hash": string,
    "open": string,
    "close": string,
    "artifacts_url": string,
    "artifacts_hash": string
  }

[...]
#+end_src

As well as the storage value:

#+begin_src python
contract.storage()
#+end_src

#+begin_src python
{'admin': 'tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb', 'manifest_url': '', 'manifest_hash': '', 'open': '', 'close': '', 'artifacts_url': '', 'artifacts_hash': ''}
#+end_src

We can see what the entrypoint type is:

#+begin_src python
contract.open
#+end_src

#+begin_src python
[...]

Typedef
$open:
	{
	  "open": string,
	  "manifest_url": string,
	  "manifest_hash": string
	}

[...]
#+end_src

And call it seemlessly:

#+begin_src python
contract.open("4-mar-21", "http://my_manifest", "134AUIE134EI").inject()
#+end_src

#+begin_src python
[...]
#+end_src

#+begin_src python
contract.storage()
#+end_src

#+begin_src python
{'admin': 'tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb', 'manifest_url': 'http://my_manifest', 'manifest_hash': '134AUIE134EI', 'open': '4-mar-21', 'close': '', 'artifacts_url': '', 'artifacts_hash': ''}
#+end_src

We can also call the contract from another address than the storage admin and witness the `FAILWITH` exception:

#+begin_src python
from pytezos.rpc.errors import MichelsonError

key2 = "edsk3RFfvaFaxbHx8BMtEW1rKQcPtDML3LXjNqMNLCzC3wLC1bWbAt"
client2 = pytezos.using(key=key2, shell=sandbox_url)
try:
    client2.contract(contract_id).open("foobar", "foobar", "foobar").inject()
    assert 0
except MichelsonError:
    assert 1
#+end_src

* Pass 1: AST expansion

** Class rewritting

We'd like to implement classes by rewritting them to classless Python first and compiling the new AST rather than compiling classes to Michelson directly. The idea is to rewritte the following:

#+begin_src python
class User:
   def __init__(a: int, b: str):
        self.a, self.b = a, b

    def method1(self, arg1: int, arg2: int) -> string:
        self.a = arg1 + arg2
        return "success"

    def method2(self, arg1: str, arg2: str) -> None:
        self.b = arg1 + arg2

user = User(1, "yo")
user.a = 10
user.method1(1, 2)
user.method2("yo", "lo")
#+end_src

As:

#+begin_src python
@dataclass 
class __User_self:
    a: int
    b: str

def __User___init__(a: int, b:str):
    return __User_self(a, b)

def __User_method1(self: __User_self, arg1: int, arg2: int) -> Tuple[__User_self, str]:
    self.a = arg1 + arg2
    return self, "success"

def __User_method2(self: __User_self, arg1: int, arg2: int) -> __User_self:
    self.b = arg1 + arg2
    return self

user = __User___init__(1, "yo")
user.a = 10
user = _User_method1(user, 1, 2)[0]
user = _User_method2(user, "yo", "lo")
#+end_src

** Closures

Similarly, closures can be compiled without touching the Michelson generator by simply rewritting the Python to « closureless » code. We want to transform:

#+begin_src python
a = "foo"
b = 1
c = 2
def f(d: int) -> int
    return len(a) + b + d
d = f(2) + c
#+end_src

Into:

#+begin_src python
a = "foo"
b = 1
def (a: str, b: int, d: int) -> int
    return len(a) + b + d
d = f(a, b, 2) + c
#+end_src

This will ensure that the variables used from the closure are always at the same position on the stack relative to the function body.
