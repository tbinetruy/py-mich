* Goal of the project

We'd like to compile Python code to Tezos' Micelson bytecode using Python's  ~ast~ module. So fare, what has been implemented is:

- a virtual machine with a Michelson-like bytecode. Ideally it would need to be identical rather than inspired, I will be working on this in the following weeks [1]. The VM is in ~vm.py~.
- a compiler backend from a Python ast to the Michelson implemented in the VM to speed up development and allow easy testing. The compiler is in ~compiler.py~.

[1] https://tezos.gitlab.io/whitedoc/michelson.html

* Usage

So far, only number variables and additions have been implemented in the compiler :D I'll update the readme as things evolve.

Here is an example of how to declare and call functions and variables. For a more complex example, with nest functions and closures, have a look at ~main.py~

#+begin_src python :exports both :results output
from vm import VM
from compiler import Compiler

vm = VM(isDebug=True)
source = "baz = 1 \ndef foo(a): \n    b = 2 \n    return a + b + 3 \nbar = foo(baz) \nfff = foo(bar) \nfoo(foo(bar))"""
c = Compiler(source, isDebug=False)
instructions = c.compile(c.ast)

log = lambda msg: print(f"\n*** {msg}\n")
log("SOURCES")
print(source)

log("EXECUTION")
# Leaves us with the following VM state:
# ("S: [1, '[func]', 6, 11, ('*', 16)] ; sp: ", '4')
vm._run_instructions(instructions)
#+end_src

#+RESULTS:
#+begin_example

*** SOURCES

baz = 1 
def foo(a): 
    b = 2 
    return a + b + 3 
bar = foo(baz) 
fff = foo(bar) 
foo(foo(bar))

*** EXECUTION

===  COMMENT ['baz = 1'] {}  ===
('S: [] ; sp: ', '-1')
('S: [] ; sp: ', '-1')
===  PUSH [1] {}  ===
('S: [] ; sp: ', '-1')
("S: [('*', 1)] ; sp: ", '0')
===  COMMENT ['Storing function foo at 1'] {}  ===
("S: [('*', 1)] ; sp: ", '0')
("S: [('*', 1)] ; sp: ", '0')
===  PUSH [[Instr(name='COMMENT', args=['b = 2'], kwargs={}), Instr(name='PUSH', args=[2], kwargs={}), Instr(name='COMMENT', args=['Loading a at 2, e.sp = 3, jump = 1'], kwargs={}), Instr(name='DIP', args=[1], kwargs={}), Instr(name='DUP', args=[], kwargs={}), Instr(name='DIG', args=[1], kwargs={}), Instr(name='COMMENT', args=['Loading b at 3, e.sp = 4, jump = 1'], kwargs={}), Instr(name='DIP', args=[1], kwargs={}), Instr(name='DUP', args=[], kwargs={}), Instr(name='DIG', args=[1], kwargs={}), Instr(name='ADD', args=[], kwargs={}), Instr(name='PUSH', args=[3], kwargs={}), Instr(name='ADD', args=[], kwargs={}), Instr(name='COMMENT', args=['Freeing var b at 3'], kwargs={}), Instr(name='DIP', args=[1], kwargs={}), Instr(name='DROP', args=[], kwargs={}), Instr(name='IIP', args=[1], kwargs={}), Instr(name='COMMENT', args=['Freeing var a at 2'], kwargs={}), Instr(name='DIP', args=[1], kwargs={}), Instr(name='DROP', args=[], kwargs={}), Instr(name='IIP', args=[1], kwargs={})]] {}  ===
("S: [('*', 1)] ; sp: ", '0')
("S: [1, ('*', '[func]')] ; sp: ", '1')
===  COMMENT ['bar = [object]'] {}  ===
("S: [1, ('*', '[func]')] ; sp: ", '1')
("S: [1, ('*', '[func]')] ; sp: ", '1')
===  COMMENT ['Moving to function foo at 1, e.sp = 1'] {}  ===
("S: [1, ('*', '[func]')] ; sp: ", '1')
("S: [1, ('*', '[func]')] ; sp: ", '1')
===  DIP [0] {}  ===
("S: [1, ('*', '[func]')] ; sp: ", '1')
("S: [1, ('*', '[func]')] ; sp: ", '1')
===  COMMENT ['Loading baz at 0, e.sp = 1, jump = 1'] {}  ===
("S: [1, ('*', '[func]')] ; sp: ", '1')
("S: [1, ('*', '[func]')] ; sp: ", '1')
===  DIP [1] {}  ===
("S: [1, ('*', '[func]')] ; sp: ", '1')
("S: [('*', 1), '[func]'] ; sp: ", '0')
===  DUP [] {}  ===
("S: [('*', 1), '[func]'] ; sp: ", '0')
("S: [1, ('*', 1), '[func]'] ; sp: ", '1')
===  DIG [1] {}  ===
("S: [1, ('*', 1), '[func]'] ; sp: ", '1')
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
===  COMMENT ['Executing function foo at 1'] {}  ===
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
===  EXEC [] {}  ===
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
@@@@@@@ Start executing function @@@@@@@
===  COMMENT ['b = 2'] {}  ===
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
===  PUSH [2] {}  ===
("S: [1, '[func]', ('*', 1)] ; sp: ", '2')
("S: [1, '[func]', 1, ('*', 2)] ; sp: ", '3')
===  COMMENT ['Loading a at 2, e.sp = 3, jump = 1'] {}  ===
("S: [1, '[func]', 1, ('*', 2)] ; sp: ", '3')
("S: [1, '[func]', 1, ('*', 2)] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 1, ('*', 2)] ; sp: ", '3')
("S: [1, '[func]', ('*', 1), 2] ; sp: ", '2')
===  DUP [] {}  ===
("S: [1, '[func]', ('*', 1), 2] ; sp: ", '2')
("S: [1, '[func]', 1, ('*', 1), 2] ; sp: ", '3')
===  DIG [1] {}  ===
("S: [1, '[func]', 1, ('*', 1), 2] ; sp: ", '3')
("S: [1, '[func]', 1, 2, ('*', 1)] ; sp: ", '4')
===  COMMENT ['Loading b at 3, e.sp = 4, jump = 1'] {}  ===
("S: [1, '[func]', 1, 2, ('*', 1)] ; sp: ", '4')
("S: [1, '[func]', 1, 2, ('*', 1)] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 1, 2, ('*', 1)] ; sp: ", '4')
("S: [1, '[func]', 1, ('*', 2), 1] ; sp: ", '3')
===  DUP [] {}  ===
("S: [1, '[func]', 1, ('*', 2), 1] ; sp: ", '3')
("S: [1, '[func]', 1, 2, ('*', 2), 1] ; sp: ", '4')
===  DIG [1] {}  ===
("S: [1, '[func]', 1, 2, ('*', 2), 1] ; sp: ", '4')
("S: [1, '[func]', 1, 2, 1, ('*', 2)] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 1, 2, 1, ('*', 2)] ; sp: ", '5')
("S: [1, '[func]', 1, 2, ('*', 3)] ; sp: ", '4')
===  PUSH [3] {}  ===
("S: [1, '[func]', 1, 2, ('*', 3)] ; sp: ", '4')
("S: [1, '[func]', 1, 2, 3, ('*', 3)] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 1, 2, 3, ('*', 3)] ; sp: ", '5')
("S: [1, '[func]', 1, 2, ('*', 6)] ; sp: ", '4')
===  COMMENT ['Freeing var b at 3'] {}  ===
("S: [1, '[func]', 1, 2, ('*', 6)] ; sp: ", '4')
("S: [1, '[func]', 1, 2, ('*', 6)] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 1, 2, ('*', 6)] ; sp: ", '4')
("S: [1, '[func]', 1, ('*', 2), 6] ; sp: ", '3')
===  DROP [] {}  ===
("S: [1, '[func]', 1, ('*', 2), 6] ; sp: ", '3')
("S: [1, '[func]', ('*', 1), 6] ; sp: ", '2')
===  IIP [1] {}  ===
("S: [1, '[func]', ('*', 1), 6] ; sp: ", '2')
("S: [1, '[func]', 1, ('*', 6)] ; sp: ", '3')
===  COMMENT ['Freeing var a at 2'] {}  ===
("S: [1, '[func]', 1, ('*', 6)] ; sp: ", '3')
("S: [1, '[func]', 1, ('*', 6)] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 1, ('*', 6)] ; sp: ", '3')
("S: [1, '[func]', ('*', 1), 6] ; sp: ", '2')
===  DROP [] {}  ===
("S: [1, '[func]', ('*', 1), 6] ; sp: ", '2')
("S: [1, ('*', '[func]'), 6] ; sp: ", '1')
===  IIP [1] {}  ===
("S: [1, ('*', '[func]'), 6] ; sp: ", '1')
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
@@@@@@@ End executing function @@@@@@@
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
===  DIG [0] {}  ===
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
===  COMMENT ['fff = [object]'] {}  ===
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
===  COMMENT ['Moving to function foo at 1, e.sp = 2'] {}  ===
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
===  DIP [1] {}  ===
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
("S: [1, ('*', '[func]'), 6] ; sp: ", '1')
===  COMMENT ['Loading bar at 2, e.sp = 1, jump = -1'] {}  ===
("S: [1, ('*', '[func]'), 6] ; sp: ", '1')
("S: [1, ('*', '[func]'), 6] ; sp: ", '1')
===  DIP [-1] {}  ===
("S: [1, ('*', '[func]'), 6] ; sp: ", '1')
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
===  DUP [] {}  ===
("S: [1, '[func]', ('*', 6)] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 6)] ; sp: ", '3')
===  DIG [-1] {}  ===
("S: [1, '[func]', 6, ('*', 6)] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
===  COMMENT ['Executing function foo at 1'] {}  ===
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
===  EXEC [] {}  ===
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
@@@@@@@ Start executing function @@@@@@@
===  COMMENT ['b = 2'] {}  ===
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
===  PUSH [2] {}  ===
("S: [1, '[func]', ('*', 6), 6] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 2), 6] ; sp: ", '3')
===  COMMENT ['Loading a at 2, e.sp = 3, jump = 1'] {}  ===
("S: [1, '[func]', 6, ('*', 2), 6] ; sp: ", '3')
("S: [1, '[func]', 6, ('*', 2), 6] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, ('*', 2), 6] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 2, 6] ; sp: ", '2')
===  DUP [] {}  ===
("S: [1, '[func]', ('*', 6), 2, 6] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 6), 2, 6] ; sp: ", '3')
===  DIG [1] {}  ===
("S: [1, '[func]', 6, ('*', 6), 2, 6] ; sp: ", '3')
("S: [1, '[func]', 6, 2, ('*', 6), 6] ; sp: ", '4')
===  COMMENT ['Loading b at 3, e.sp = 4, jump = 1'] {}  ===
("S: [1, '[func]', 6, 2, ('*', 6), 6] ; sp: ", '4')
("S: [1, '[func]', 6, 2, ('*', 6), 6] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, 2, ('*', 6), 6] ; sp: ", '4')
("S: [1, '[func]', 6, ('*', 2), 6, 6] ; sp: ", '3')
===  DUP [] {}  ===
("S: [1, '[func]', 6, ('*', 2), 6, 6] ; sp: ", '3')
("S: [1, '[func]', 6, 2, ('*', 2), 6, 6] ; sp: ", '4')
===  DIG [1] {}  ===
("S: [1, '[func]', 6, 2, ('*', 2), 6, 6] ; sp: ", '4')
("S: [1, '[func]', 6, 2, 6, ('*', 2), 6] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 6, 2, 6, ('*', 2), 6] ; sp: ", '5')
("S: [1, '[func]', 6, 2, ('*', 8), 6] ; sp: ", '4')
===  PUSH [3] {}  ===
("S: [1, '[func]', 6, 2, ('*', 8), 6] ; sp: ", '4')
("S: [1, '[func]', 6, 2, 8, ('*', 3), 6] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 6, 2, 8, ('*', 3), 6] ; sp: ", '5')
("S: [1, '[func]', 6, 2, ('*', 11), 6] ; sp: ", '4')
===  COMMENT ['Freeing var b at 3'] {}  ===
("S: [1, '[func]', 6, 2, ('*', 11), 6] ; sp: ", '4')
("S: [1, '[func]', 6, 2, ('*', 11), 6] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, 2, ('*', 11), 6] ; sp: ", '4')
("S: [1, '[func]', 6, ('*', 2), 11, 6] ; sp: ", '3')
===  DROP [] {}  ===
("S: [1, '[func]', 6, ('*', 2), 11, 6] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 11, 6] ; sp: ", '2')
===  IIP [1] {}  ===
("S: [1, '[func]', ('*', 6), 11, 6] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 11), 6] ; sp: ", '3')
===  COMMENT ['Freeing var a at 2'] {}  ===
("S: [1, '[func]', 6, ('*', 11), 6] ; sp: ", '3')
("S: [1, '[func]', 6, ('*', 11), 6] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, ('*', 11), 6] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 11, 6] ; sp: ", '2')
===  DROP [] {}  ===
("S: [1, '[func]', ('*', 6), 11, 6] ; sp: ", '2')
("S: [1, ('*', '[func]'), 11, 6] ; sp: ", '1')
===  IIP [1] {}  ===
("S: [1, ('*', '[func]'), 11, 6] ; sp: ", '1')
("S: [1, '[func]', ('*', 11), 6] ; sp: ", '2')
@@@@@@@ End executing function @@@@@@@
("S: [1, '[func]', ('*', 11), 6] ; sp: ", '2')
===  DIG [1] {}  ===
("S: [1, '[func]', ('*', 11), 6] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 11)] ; sp: ", '3')
===  COMMENT ['Moving to function foo at 1, e.sp = 3'] {}  ===
("S: [1, '[func]', 6, ('*', 11)] ; sp: ", '3')
("S: [1, '[func]', 6, ('*', 11)] ; sp: ", '3')
===  DIP [2] {}  ===
("S: [1, '[func]', 6, ('*', 11)] ; sp: ", '3')
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
===  COMMENT ['Moving to function foo at 1, e.sp = 1'] {}  ===
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
===  DIP [0] {}  ===
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
===  COMMENT ['Loading bar at 2, e.sp = 1, jump = -1'] {}  ===
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
===  DIP [-1] {}  ===
("S: [1, ('*', '[func]'), 6, 11] ; sp: ", '1')
("S: [1, '[func]', ('*', 6), 11] ; sp: ", '2')
===  DUP [] {}  ===
("S: [1, '[func]', ('*', 6), 11] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 6), 11] ; sp: ", '3')
===  DIG [-1] {}  ===
("S: [1, '[func]', 6, ('*', 6), 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
===  COMMENT ['Executing function foo at 1'] {}  ===
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
===  EXEC [] {}  ===
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
@@@@@@@ Start executing function @@@@@@@
===  COMMENT ['b = 2'] {}  ===
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
===  PUSH [2] {}  ===
("S: [1, '[func]', ('*', 6), 6, 11] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 2), 6, 11] ; sp: ", '3')
===  COMMENT ['Loading a at 2, e.sp = 3, jump = 1'] {}  ===
("S: [1, '[func]', 6, ('*', 2), 6, 11] ; sp: ", '3')
("S: [1, '[func]', 6, ('*', 2), 6, 11] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, ('*', 2), 6, 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 2, 6, 11] ; sp: ", '2')
===  DUP [] {}  ===
("S: [1, '[func]', ('*', 6), 2, 6, 11] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 6), 2, 6, 11] ; sp: ", '3')
===  DIG [1] {}  ===
("S: [1, '[func]', 6, ('*', 6), 2, 6, 11] ; sp: ", '3')
("S: [1, '[func]', 6, 2, ('*', 6), 6, 11] ; sp: ", '4')
===  COMMENT ['Loading b at 3, e.sp = 4, jump = 1'] {}  ===
("S: [1, '[func]', 6, 2, ('*', 6), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 6, 2, ('*', 6), 6, 11] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, 2, ('*', 6), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 6, ('*', 2), 6, 6, 11] ; sp: ", '3')
===  DUP [] {}  ===
("S: [1, '[func]', 6, ('*', 2), 6, 6, 11] ; sp: ", '3')
("S: [1, '[func]', 6, 2, ('*', 2), 6, 6, 11] ; sp: ", '4')
===  DIG [1] {}  ===
("S: [1, '[func]', 6, 2, ('*', 2), 6, 6, 11] ; sp: ", '4')
("S: [1, '[func]', 6, 2, 6, ('*', 2), 6, 11] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 6, 2, 6, ('*', 2), 6, 11] ; sp: ", '5')
("S: [1, '[func]', 6, 2, ('*', 8), 6, 11] ; sp: ", '4')
===  PUSH [3] {}  ===
("S: [1, '[func]', 6, 2, ('*', 8), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 6, 2, 8, ('*', 3), 6, 11] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 6, 2, 8, ('*', 3), 6, 11] ; sp: ", '5')
("S: [1, '[func]', 6, 2, ('*', 11), 6, 11] ; sp: ", '4')
===  COMMENT ['Freeing var b at 3'] {}  ===
("S: [1, '[func]', 6, 2, ('*', 11), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 6, 2, ('*', 11), 6, 11] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, 2, ('*', 11), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 6, ('*', 2), 11, 6, 11] ; sp: ", '3')
===  DROP [] {}  ===
("S: [1, '[func]', 6, ('*', 2), 11, 6, 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 11, 6, 11] ; sp: ", '2')
===  IIP [1] {}  ===
("S: [1, '[func]', ('*', 6), 11, 6, 11] ; sp: ", '2')
("S: [1, '[func]', 6, ('*', 11), 6, 11] ; sp: ", '3')
===  COMMENT ['Freeing var a at 2'] {}  ===
("S: [1, '[func]', 6, ('*', 11), 6, 11] ; sp: ", '3')
("S: [1, '[func]', 6, ('*', 11), 6, 11] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 6, ('*', 11), 6, 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 6), 11, 6, 11] ; sp: ", '2')
===  DROP [] {}  ===
("S: [1, '[func]', ('*', 6), 11, 6, 11] ; sp: ", '2')
("S: [1, ('*', '[func]'), 11, 6, 11] ; sp: ", '1')
===  IIP [1] {}  ===
("S: [1, ('*', '[func]'), 11, 6, 11] ; sp: ", '1')
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
@@@@@@@ End executing function @@@@@@@
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
===  DIG [0] {}  ===
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
===  COMMENT ['Executing function foo at 1'] {}  ===
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
===  EXEC [] {}  ===
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
@@@@@@@ Start executing function @@@@@@@
===  COMMENT ['b = 2'] {}  ===
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
===  PUSH [2] {}  ===
("S: [1, '[func]', ('*', 11), 6, 11] ; sp: ", '2')
("S: [1, '[func]', 11, ('*', 2), 6, 11] ; sp: ", '3')
===  COMMENT ['Loading a at 2, e.sp = 3, jump = 1'] {}  ===
("S: [1, '[func]', 11, ('*', 2), 6, 11] ; sp: ", '3')
("S: [1, '[func]', 11, ('*', 2), 6, 11] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 11, ('*', 2), 6, 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 11), 2, 6, 11] ; sp: ", '2')
===  DUP [] {}  ===
("S: [1, '[func]', ('*', 11), 2, 6, 11] ; sp: ", '2')
("S: [1, '[func]', 11, ('*', 11), 2, 6, 11] ; sp: ", '3')
===  DIG [1] {}  ===
("S: [1, '[func]', 11, ('*', 11), 2, 6, 11] ; sp: ", '3')
("S: [1, '[func]', 11, 2, ('*', 11), 6, 11] ; sp: ", '4')
===  COMMENT ['Loading b at 3, e.sp = 4, jump = 1'] {}  ===
("S: [1, '[func]', 11, 2, ('*', 11), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 11, 2, ('*', 11), 6, 11] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 11, 2, ('*', 11), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 11, ('*', 2), 11, 6, 11] ; sp: ", '3')
===  DUP [] {}  ===
("S: [1, '[func]', 11, ('*', 2), 11, 6, 11] ; sp: ", '3')
("S: [1, '[func]', 11, 2, ('*', 2), 11, 6, 11] ; sp: ", '4')
===  DIG [1] {}  ===
("S: [1, '[func]', 11, 2, ('*', 2), 11, 6, 11] ; sp: ", '4')
("S: [1, '[func]', 11, 2, 11, ('*', 2), 6, 11] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 11, 2, 11, ('*', 2), 6, 11] ; sp: ", '5')
("S: [1, '[func]', 11, 2, ('*', 13), 6, 11] ; sp: ", '4')
===  PUSH [3] {}  ===
("S: [1, '[func]', 11, 2, ('*', 13), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 11, 2, 13, ('*', 3), 6, 11] ; sp: ", '5')
===  ADD [] {}  ===
("S: [1, '[func]', 11, 2, 13, ('*', 3), 6, 11] ; sp: ", '5')
("S: [1, '[func]', 11, 2, ('*', 16), 6, 11] ; sp: ", '4')
===  COMMENT ['Freeing var b at 3'] {}  ===
("S: [1, '[func]', 11, 2, ('*', 16), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 11, 2, ('*', 16), 6, 11] ; sp: ", '4')
===  DIP [1] {}  ===
("S: [1, '[func]', 11, 2, ('*', 16), 6, 11] ; sp: ", '4')
("S: [1, '[func]', 11, ('*', 2), 16, 6, 11] ; sp: ", '3')
===  DROP [] {}  ===
("S: [1, '[func]', 11, ('*', 2), 16, 6, 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 11), 16, 6, 11] ; sp: ", '2')
===  IIP [1] {}  ===
("S: [1, '[func]', ('*', 11), 16, 6, 11] ; sp: ", '2')
("S: [1, '[func]', 11, ('*', 16), 6, 11] ; sp: ", '3')
===  COMMENT ['Freeing var a at 2'] {}  ===
("S: [1, '[func]', 11, ('*', 16), 6, 11] ; sp: ", '3')
("S: [1, '[func]', 11, ('*', 16), 6, 11] ; sp: ", '3')
===  DIP [1] {}  ===
("S: [1, '[func]', 11, ('*', 16), 6, 11] ; sp: ", '3')
("S: [1, '[func]', ('*', 11), 16, 6, 11] ; sp: ", '2')
===  DROP [] {}  ===
("S: [1, '[func]', ('*', 11), 16, 6, 11] ; sp: ", '2')
("S: [1, ('*', '[func]'), 16, 6, 11] ; sp: ", '1')
===  IIP [1] {}  ===
("S: [1, ('*', '[func]'), 16, 6, 11] ; sp: ", '1')
("S: [1, '[func]', ('*', 16), 6, 11] ; sp: ", '2')
@@@@@@@ End executing function @@@@@@@
("S: [1, '[func]', ('*', 16), 6, 11] ; sp: ", '2')
===  DIG [2] {}  ===
("S: [1, '[func]', ('*', 16), 6, 11] ; sp: ", '2')
("S: [1, '[func]', 6, 11, ('*', 16)] ; sp: ", '4')
#+end_example


* Deploy on sandbox

Compile contract:

#+begin_src python
from compiler import Compiler
import json

source = """
class Contract:
    def incrementByTwo(a: int) -> int:
        b = 1
        return a + b + 1

    def bar(b: int) -> int:
        return b
"""
contract = Compiler(source).compile().contract
micheline = CompilerBackend().compile_contract(contract)

with open("my_contract.json", "w+") as f:
    f.write(json.dumps(micheline))
#+end_src

Run contract on tezos sandbox using pytezos:

#+begin_src python
from pytezos import pytezos

key = pytezos.key.from_encoded_key("edsk3QoqBuvdamxouPhin7swCvkQNgq4jP5KZPbwWNnwdZpSpJiEbq")
sandbox_url = "http://tz:20000"
client = pytezos.using(key=key, shell=sandbox_url)

from pytezos import Contract

with open("my_contract.json") as f:
    text = f.read()

import json
foo = json.loads(text)
operation = client.origination(dict(code=foo, storage={"int": "1"})).autofill().sign().inject()
result = client.shell.blocks[-200:].find_operation(operation['hash'])
contract_id = result['contents'][0]['metadata']['operation_result']['originated_contracts'][0]
contract = client.contract(contract_id)

assert conrtact.storage() == 1
contract.entrypoint_0(10).inject()  # bar entrypoint
assert contract.storage() == 10
conrtact.entrypoint_1(10).inject()  # incrementByTwo entrypoint
assert contract.storage() == 12
#+end_src

* Pass 1: AST expansion

** Class rewritting

We'd like to implement classes by rewritting them to classless Python first and compiling the new AST rather than compiling classes to Michelson directly. The idea is to rewritte the following:

#+begin_src python
class User:
   def __init__(a: int, b: str):
        self.a, self.b = a, b

    def method1(self, arg1: int, arg2: int) -> string:
        self.a = arg1 + arg2
        return "success"

    def method2(self, arg1: str, arg2: str) -> None:
        self.b = arg1 + arg2

user = User(1, "yo")
user.a = 10
user.method1(1, 2)
user.method2("yo", "lo")
#+end_src

As:

#+begin_src python
@dataclass 
class __User_self:
    a: int
    b: str

def __User___init__(a: int, b:str):
    return __User_self(a, b)

def __User_method1(self: __User_self, arg1: int, arg2: int) -> Tuple[__User_self, str]:
    self.a = arg1 + arg2
    return self, "success"

def __User_method2(self: __User_self, arg1: int, arg2: int) -> __User_self:
    self.b = arg1 + arg2
    return self

user = __User___init__(1, "yo")
user.a = 10
user = _User_method1(user, 1, 2)[0]
user = _User_method2(user, "yo", "lo")
#+end_src

** Closures

Similarly, closures can be compiled without touching the Michelson generator by simply rewritting the Python to « closureless » code. We want to transform:

#+begin_src python
a = "foo"
b = 1
c = 2
def f(d: int) -> int
    return len(a) + b + d
d = f(2) + c
#+end_src

Into:

#+begin_src python
a = "foo"
b = 1
def (a: str, b: int, d: int) -> int
    return len(a) + b + d
d = f(a, b, 2) + c
#+end_src

This will ensure that the variables used from the closure are always at the same position on the stack relative to the function body.
